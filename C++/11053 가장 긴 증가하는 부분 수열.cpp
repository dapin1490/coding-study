// 풀이 참고 링크
// (1) https://bitwise.tistory.com/215
// (2) https://yabmoons.tistory.com/516
// 벡터 함수 참고 링크 https://blockdmask.tistory.com/70
// 벡터는 배열과 스택을 합친 것과 비슷합니다.
// 배열과 달리 사용자가 크기를 변경할 수 있지만, 원소를 직접 집어넣거나 삭제하는 건 마지막 원소에 대해서만 가능합니다.
// 사용은 배열과 거의 똑같이 할 수 있습니다.

/*
논리 설명 : 첫 문제라 길고 자세하게 썼습니다만 다음 문제부터는 이 논리를 조금씩 활용하기 때문에 설명이 간결해집니다.
기본적으로 모든 요소는 길이가 1인 부분 수열과 같다. 그러므로 아래 있는 벡터 d는 모든 값이 1로 초기화된다.
첫 번째 원소부터 증가하는 부분 수열을 판단하는데, 이때 판단의 방향은 지금 검사하는 원소보다 이전의 원소를 본다.
즉 지금 검사하는 원소를 마지막 원소로 하는 부분 수열을 찾는다.

예를 들어 [1, 2, 1, 3]이라는 수열이 있다고 하자. 이때 부분 수열 길이 배열은 [1, 1, 1, 1]로 초기화된다. 이유는 11번 줄에 설명되어 있다.
0번 원소인 1에서는 이전에 원소가 없으므로 부분 수열의 길이는 1이다.
1번 원소인 2에서는 이전의 원소인 1을 검사한다. 편의상 검사의 기준이 되는 원소를 key, 비교하여 검사하는 원소를 value라고 한다. 지금은 key = 2, value = 1이다.
	value < key이고, value의 부분 수열 값이 key의 부분 수열 값보다 크거나 같으므로
	value의 부분 수열 뒤에 key를 추가한다는 의미로, value의 부분 수열 값에 1을 더하여 key의 부분 수열 값으로 저장한다.
	이제 부분 수열 길이 배열은 [1, 2, 1, 1]이다. 그리고 더 이상 검사할 value가 없으므로 다음 key로 넘어간다.
2번 원소인 1에서는 바로 앞의 2를 value로 삼아 먼저 검사하는데, value >= key이므로 이 value의 부분 수열 뒤에 key를 추가하는 것은 부적절하다. 다음 value로 넘어간다.
	다음 value는 1인데, 이 역시 방금과 같이 부적절하다. 다음 value가 없으므로 다음 key로 넘어간다.
	이때 부분 수열 길이 배열은 [1, 2, 1, 1]이다.
3번 원소인 3에서는 먼저 2번 원소인 1을 value로 삼아 검사한다. value < key이고, 부분 수열의 길이 배열 값도 value >= key이기 때문에 19번 줄과 같은 방식으로 값을 업데이트한다.
	현재 부분 수열 길이 배열은 [1, 2, 1, 2]이다.
	다음 value는 1번 원소인 2이고, 이 또한 조건을 만족하므로 다시 업데이트한다. 이제 부분 수열 길이 배열은 [1, 2, 1, 3]이다.
	다음 value는 0번 원소인 1인데, 그 값이 key보다 작긴 하지만 부분 수열 길이 배열의 값이 크거나 같지 못하므로 업데이트하지 않는다. 다음 value도 없고 다음 key도 없으므로 검사가 끝난다.
최종 부분 수열 길이 배열은 [1, 2, 1, 3]이 된다. 답은 3으로 출력하면 된다.
*/

#include <iostream>
#include <vector>
using namespace std;

// 증가하는 수열 찾기
int finder(int n);

vector<int> v; // 입력받을 벡터
vector<int> d; // 증가하는 부분 수열의 길이만 저장하는 벡터. 
int t, cnt = 1; // 입력받을 수열의 크기, 가장 긴 부분 수열의 길이. 가장 짧은 부분 수열의 길이가 1이므로 cnt는 1로 초기화했습니다.

int main()
{
	// 빠른 입출력 : 사용하지 않아도 무방
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int a; // 벡터에 입력받은 값을 집어넣기 위해 사용할 변수. 이후에도 반복 횟수와 함수 호출 시 전달할 인자로 재사용합니다.
	cin >> t;
	d.resize(t, 1); // 입력받은 수열의 크기만큼 부분 수열 길이 벡터를 초기화합니다.
	for (int i = 0; i < t; i++) { // 수열 입력받기
		cin >> a;
		v.push_back(a);
	}

	a = 1; // 첫 번째 원소를 마지막 원소로 하는 부분 수열의 길이는 무조건 1이므로
	// 두 번째 원소, 즉 인덱스가 1인 원소에서부터 함수를 호출하면 불필요하게 함수가 호출되는 것을 줄일 수 있습니다.
	while (true) {
		if (a >= t) // a가 t와 같은 값이 되면 수열의 모든 원소에 대한 부분 수열을 검사했다는 뜻이므로 반복 종료
			break;

		int k = finder(a); // 아래에 있는 if문에 finder(a) 값을 바로 넣어도 되지만
		// 그렇게 할 경우 if 조건절에서 한 번, cnt를 업데이트 하는 부분에서 한 번, 총 두 번 똑같은 함수를 똑같이 실행하기 때문에 전체 프로그램 실행 시간이 길어집니다.
		// 그러므로 k라는 변수에 함수를 한 번 호출하여 반환된 값을 저장해 함수를 반복하여 호출하지 않게 합니다.
		if (cnt < k) { // 부분 수열의 길이가 길 때에만 cnt 업데이트.
			// 물론 이 선택문 없이 수열 전체에 대해 부분 수열의 길이를 구하고 그중 최댓값만을 취해도 됩나다. 이 방식의 풀이는 11054번에서 사용했습니다.
			cnt = k;
		}
		a++; // 사용한 a 업데이트
	}

	cout << cnt; // 반복 종료 후 cnt는 답으로 출력

	return 0;
}

// 증가하는 수열 찾기
int finder(int n) // 부분 수열의 마지막 원소가 될 요소의 인덱스를 인자로 받습니다.
{
	for (int i = n; i >= 0; i--) { // 전달받은 원소(key)로부터 "이전에 있는 원소" 중,
		if (v[i] < v[n] && d[i] >= d[n]) { // "key보다 작고", "현재 key가 만들 수 있는 부분 수열의 길이보다 긴 것을 갖는" 원소를 찾아
			d[n] = d[i] + 1; // 해당 원소의 부분 수열을 key의 부분 수열로 포함합니다.
		}
	}

	return d[n]; // 인자로 받은 원소의 최대 부분 수열 길이를 반환합니다.
}
